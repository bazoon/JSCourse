<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>Функции</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Функции"><h1 id="Функции" class="header"><a href="#Функции">Функции</a></h1></div>

<div id="Функции-Функция - это блок кода созданный для выполнения определенной задачи. Функции вJS создаются с помощью ключевого слова function. Существует несколько способов объявить функцию:"><h2 id="Функция - это блок кода созданный для выполнения определенной задачи. Функции вJS создаются с помощью ключевого слова function. Существует несколько способов объявить функцию:" class="header"><a href="#Функции-Функция - это блок кода созданный для выполнения определенной задачи. Функции вJS создаются с помощью ключевого слова function. Существует несколько способов объявить функцию:" class="justcenter">Функция - это блок кода созданный для выполнения определенной задачи. Функции вJS создаются с помощью ключевого слова function. Существует несколько способов объявить функцию:</a></h2></div>

<ol>
<li>
Function declaration - функция будет доступна везде в файле где она объявлен.

</ol>

<pre javascript>
    function hello() {
      console.log("hello");
    }
</pre>

<ol>
<li>
Function expression - функция будет доступна после строки, где она была объявлена.

</ol>

<pre javascript>
    const hello = function() {

    console.log('hello');

    }
</pre>

<ol>
<li>
Есть способ создания функций через стрелку. Созданная таким образом функция отличается от обычных функций в существенных аспектах.

</ol>

<pre javascript>
    const hello = () =&gt; { console.log('hello') }
</pre>

<p>
Для вызова функции необходимо использовать ее имя с круглыми скобками. Пример: sayHello()
</p>

<p>
Функции могут принимать параметры и возвращать значения. Если функция не содержит ключевое слово return, то она вернет undefined.
</p>

<pre javascript>
    function sum(a, b) {

    return a + b;

    }

    sum(1, 3) // Вызов функции с передачей в нее двух аргументов.
</pre>

<p>
Функция может принимать множество аргументов, но при вызове функции не происходит проверки, что передано необходимое их число. Пример:
</p>

<pre javascript>
    function sum3(a, b, c) {

    return a+b+c;

    }

    sum3(10, 20) // =&gt; NaN
</pre>

<p>
Причина такого поведения в том, что непроинициализированне параметры функции становятся undefined
</p>

<div id="Функции-Функция создает отдельную область видимости. Переменные объявленные внутри функции являются локальными - видны только внутри этой функции."><h2 id="Функция создает отдельную область видимости. Переменные объявленные внутри функции являются локальными - видны только внутри этой функции." class="header"><a href="#Функции-Функция создает отдельную область видимости. Переменные объявленные внутри функции являются локальными - видны только внутри этой функции." class="justcenter">Функция создает отдельную область видимости. Переменные объявленные внутри функции являются локальными - видны только внутри этой функции.</a></h2></div>
<pre javascript>
    function doJob() {

    const a = 100;

    }

    console.log(a) =&gt;исключение ReferenceError, переменная а тут не видна
</pre>

<div id="Функции-Функции являются объектами первого класса. Это означает, что они являются значениями, наподобие примитивов - их можно передавать в другие функции и возвращать из функции. Их можно присваивать переменным."><h2 id="Функции являются объектами первого класса. Это означает, что они являются значениями, наподобие примитивов - их можно передавать в другие функции и возвращать из функции. Их можно присваивать переменным." class="header"><a href="#Функции-Функции являются объектами первого класса. Это означает, что они являются значениями, наподобие примитивов - их можно передавать в другие функции и возвращать из функции. Их можно присваивать переменным." class="justcenter">Функции являются объектами первого класса. Это означает, что они являются значениями, наподобие примитивов - их можно передавать в другие функции и возвращать из функции. Их можно присваивать переменным.</a></h2></div>

<pre javascript>
    function foo() {

    }
  

    const bar = foo;

    bar(); вызываем код внутри foo через bar
</pre>

<div id="Функции-Функции не являются методами, даже в том случае, если они объявлены внутри класса. Точнее сказать, их можно использовать как методы, но они не принадлежат классу, в котором объявлены."><h2 id="Функции не являются методами, даже в том случае, если они объявлены внутри класса. Точнее сказать, их можно использовать как методы, но они не принадлежат классу, в котором объявлены." class="header"><a href="#Функции-Функции не являются методами, даже в том случае, если они объявлены внутри класса. Точнее сказать, их можно использовать как методы, но они не принадлежат классу, в котором объявлены.">Функции не являются методами, даже в том случае, если они объявлены внутри класса. Точнее сказать, их можно использовать как методы, но они не принадлежат классу, в котором объявлены.</a></h2></div>

<pre javascript>

    class Example {
      sayHi() {

      }
    }
  

    const ex = new Example(); // создается объект

    const sayHi = ex.sayHi();

    sayHi(); =&gt; при вызове функция выполнится, как если бы она была объявлена вне класса.
</pre>

<div id="Функции-Замыкания."><h2 id="Замыкания." class="header"><a href="#Функции-Замыкания.">Замыкания.</a></h2></div>

<p>
Как было написано выше, функции создают внутри себя локальную область видимости. Но при этом, имеют доступ к переменным объявленным вне функции. Можно сказать, что вокруг функции существует контекст - можно представить его как хеш, где для ключа есть значение. Переменные объявленные вне функции существуют внутри этого контекста - образуют пары: имя переменной - значение. Функцию, которая имеет доступ к внешнему контексту называют замыкание. Она замыкает - захватывает внешний контекст и имеет посредством этого доступ к внешним переменным. На практикезамыкания могут использоваться, например, для скрытия прямого доступа к данным, при этом можно определить методы доступа.
</p>

<p>
Пример:
</p>

<pre javascript>

    function getCounter() {
      let count = 0;
      return function() {
        return count++;
      }
    }

    const counter = getCounter();

    console.log(counter()) =&gt; 0

    console.log(counter()) =&gt; 1

    console.log(counter()) =&gt; 2
</pre>

<p>
Безымянная функция внутри getCounter имеет доступк переменной count. И только посредством вызова этой функции можно изменить значениеcount. При этом каждый вызов getCounter возвращает новую функцию которая имеет свою собственную переменную count.
</p>

<pre javascript>

    const counter = getCounter();

    const counter2 = getCounter();

    console.log(counter()) =&gt; 0

    console.log(counter()) =&gt; 1

    console.log(counter2()) =&gt; 0 // функция counter2 не делит переменную count с функцией counter

    Если переменная внутри функции имеет такое же имя как переменная определенная в области видимости функции, но вне ее, тогда внутри функции будет видна только внутренняя переменная.

    let a = 123;

    function bar() {

    let a = 2;

    console.log(a) // выведет 2

    }
</pre>

<div id="Задачи"><h1 id="Задачи" class="header"><a href="#Задачи">Задачи</a></h1></div>

<ol>
<li>
Написать функцию которая определяет является ли год високосным.

</ol>

<ol>
<li>
Написать функцию, которая переворачивает строку.

</ol>

<ol>
<li>
Написать функцию, которая вернет функцию, которая будет принимать 1 число и возвращать это число + 1

</ol>

<ol>
<li>
Написать функцию, которая определяет является ли строка палиндром.

</ol>

<ol>
<li>
Найти функцию, которая возвращает недостающее число. Есть последовательность [1,2,3,4...N],где N переданное в функцию число. Последовательность была перемешана и одно число из нее убрано. Необходимо вернуть из функции это число. Если последовательность содержит все числа от 1 до N,то вернуть 0.

</ol>

<div id="Вопросы"><h1 id="Вопросы" class="header"><a href="#Вопросы">Вопросы</a></h1></div>

<ol>
<li>
Какое объявление функции является неправильным?

</ol>

<ul>
<li class="done4">
function () {}

<li class="done0">
Function() {}

<li class="done0">
new function() {}

<li class="done0">
let a = function =&gt; {}

<li class="done4">
let b = () =&gt; {}

</ul>
 
<ol>
<li>
Как передать в функцию add число 3

<ul>
<li class="done4">
add(3)

<li class="done0">
add 3

<li class="done0">
add[3]

</ul>
</ol>

<ol>
<li>
Что вернет функция mystery ?

</ol>

<p>
function mystery(a, b, c) {
  return a + b + c;
}
</p>

<ul>
<li class="done0">
сумму параметров функции

<li class="done0">
строку, полученную путем конкатенации параметров функции

<li class="done4">
точный ответ неизвестен, он зависит от типов параметров функции 

</ul>

<ol>
<li>
Можно ли получить прямой доступ к переменной объявленной внутри функции?

</ol>

<ul>
<li class="done0">
да

<li class="done4">
нет

<li class="done0">
зависит от способа объявления функции

</ul>

<ol>
<li>
Что будет выведено ?

</ol>

<pre javascript>
    blah =function () {
      return lala;
      lala ="hi";
    };
    
    console.log(blah());
</pre>

<ul>
<li class="done0">
"hi"

<li class="done0">
undefined

<li class="done4">
Ошибка

</ul>

<ol>
<li>
Что будет выведено ?

</ol>

<pre javascript>
    function foo () {
      return bar();

      function bar() {
        return "abc";
      }
    }
    console.log(foo());
</pre>

<ul>
<li class="done0">
undefined

<li class="done4">
"abc"

<li class="done0">
Ошибка

</ul>

<ol>
<li>
Что будет выведено ?
<pre javascript>
    function sum(a, b) {
      return a + b;
    }

    console.log(sum(1, 2, 3, 4));
</pre>

</ol>

<ul>
<li class="done0">
NaN

<li class="done4">
3

<li class="done0">
10

</ul>

<ol>
<li>
Что будет выведено ?

</ol>

<pre javascript>
    function a(x, y, z) {
      return z;
    }
    console.log(a("blah"));
</pre>

<ul>
<li class="done0">
"blah"

<li class="done0">
NaN

<li class="done4">
undefined

</ul>

<ol>
<li>
Что будет выведено ?
<pre javascript>
    function c(f) {
      return f();
    }

    function blub() {
      return"monsters";
    }

    console.log(c(blub));
</pre>

</ol>

<ul>
<li class="done0">
Ошибка

<li class="done0">
undefined

<li class="done4">
"monsters"

</ul>

<ol>
<li>
Чему равно значение переменной result ?
<pre javascript>
    function add(a, b) {
      return a + b;
    }

    const bar = add;
    const result = bar(1, 2);
</pre>

</ol>

<ul>
<li class="done0">
Ошибка

<li class="done0">
undefined

<li class="done4">
3

</ul>

<p>
11.
</p>
<pre javascript>
    function some(fn, n) {
      return fn(n) + fn(n+1);
    }

    function sqr(n) {
      return n * n;
    }

    result = some(sqr, 10);
</pre>

<ul>
<li class="done4">
221

<li class="done0">
ошибка

<li class="done0">
undefined

<li class="done0">
21

</ul>

</body>
</html>
